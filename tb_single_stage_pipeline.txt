// Testbench for Single-Stage Pipeline Register
//
// This testbench verifies:
// - Basic data transfer
// - Backpressure handling
// - No data loss or duplication
// - Reset behavior

`timescale 1ns/1ps

module tb_pipeline_register;

    parameter DATA_WIDTH = 32;
    parameter CLK_PERIOD = 10;
    
    // DUT signals
    logic                    clk;
    logic                    rst_n;
    logic                    in_valid;
    logic                    in_ready;
    logic [DATA_WIDTH-1:0]   in_data;
    logic                    out_valid;
    logic                    out_ready;
    logic [DATA_WIDTH-1:0]   out_data;
    
    // Testbench variables
    int error_count = 0;
    int test_count = 0;
    
    // Instantiate DUT
    pipeline_register #(
        .DATA_WIDTH(DATA_WIDTH)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .in_valid(in_valid),
        .in_ready(in_ready),
        .in_data(in_data),
        .out_valid(out_valid),
        .out_ready(out_ready),
        .out_data(out_data)
    );
    
    // Clock generation
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end
    
    // Test stimulus
    initial begin
        $display("=== Starting Pipeline Register Tests ===");
        
        // Initialize
        rst_n = 0;
        in_valid = 0;
        in_data = 0;
        out_ready = 0;
        
        // Reset
        repeat(3) @(posedge clk);
        rst_n = 1;
        repeat(2) @(posedge clk);
        
        // Test 1: Basic transfer
        test_basic_transfer();
        
        // Test 2: Backpressure handling
        test_backpressure();
        
        // Test 3: Continuous flow
        test_continuous_flow();
        
        // Test 4: Random stimulus
        test_random_stimulus();
        
        // Test 5: Reset during operation
        test_reset();
        
        // Summary
        repeat(5) @(posedge clk);
        $display("\n=== Test Summary ===");
        $display("Total tests: %0d", test_count);
        $display("Errors: %0d", error_count);
        if (error_count == 0)
            $display("ALL TESTS PASSED!");
        else
            $display("TESTS FAILED!");
        
        $finish;
    end
    
    // Test 1: Basic data transfer
    task test_basic_transfer();
        logic [DATA_WIDTH-1:0] test_data;
        $display("\n--- Test 1: Basic Transfer ---");
        
        test_data = 32'hDEADBEEF;
        
        // Send data
        @(posedge clk);
        in_valid = 1;
        in_data = test_data;
        out_ready = 1;
        
        @(posedge clk);
        in_valid = 0;
        
        // Wait for output
        wait(out_valid);
        @(posedge clk);
        
        check("Basic transfer data", out_data, test_data);
        check("Output valid", out_valid, 1'b1);
        
        @(posedge clk);
        check("Output deasserts after ready", out_valid, 1'b0);
        
        out_ready = 0;
    endtask
    
    // Test 2: Backpressure handling
    task test_backpressure();
        logic [DATA_WIDTH-1:0] test_data;
        $display("\n--- Test 2: Backpressure Handling ---");
        
        test_data = 32'hCAFEBABE;
        
        // Send data with output not ready
        @(posedge clk);
        in_valid = 1;
        in_data = test_data;
        out_ready = 0;
        
        @(posedge clk);
        in_valid = 0;
        
        // Check data is held
        repeat(5) begin
            @(posedge clk);
            check("Data stable under backpressure", out_data, test_data);
            check("Valid remains high", out_valid, 1'b1);
        end
        
        // Release backpressure
        out_ready = 1;
        @(posedge clk);
        check("Data still correct after backpressure", out_data, test_data);
        
        out_ready = 0;
        @(posedge clk);
    endtask
    
    // Test 3: Continuous flow
    task test_continuous_flow();
        $display("\n--- Test 3: Continuous Flow ---");
        
        out_ready = 1;
        
        for (int i = 0; i < 10; i++) begin
            @(posedge clk);
            in_valid = 1;
            in_data = i;
            
            // Check previous data if valid
            if (i > 0) begin
                check($sformatf("Continuous flow data[%0d]", i-1), out_data, i-1);
            end
        end
        
        in_valid = 0;
        @(posedge clk);
        check("Last data in continuous flow", out_data, 9);
        
        out_ready = 0;
        @(posedge clk);
    endtask
    
    // Test 4: Random stimulus
    task test_random_stimulus();
        logic [DATA_WIDTH-1:0] sent_queue[$];
        logic [DATA_WIDTH-1:0] received_queue[$];
        logic [DATA_WIDTH-1:0] current_data;
        int cycles = 100;
        
        $display("\n--- Test 4: Random Stimulus ---");
        
        fork
            // Sender process
            begin
                for (int i = 0; i < cycles; i++) begin
                    @(posedge clk);
                    in_valid = $random % 2;
                    if (in_valid) begin
                        in_data = $random;
                        if (in_ready) begin
                            sent_queue.push_back(in_data);
                        end
                    end
                end
                in_valid = 0;
            end
            
            // Receiver process
            begin
                for (int i = 0; i < cycles; i++) begin
                    @(posedge clk);
                    out_ready = $random % 2;
                    if (out_valid && out_ready) begin
                        received_queue.push_back(out_data);
                    end
                end
                // Drain remaining
                out_ready = 1;
                repeat(10) begin
                    @(posedge clk);
                    if (out_valid && out_ready) begin
                        received_queue.push_back(out_data);
                    end
                end
                out_ready = 0;
            end
        join
        
        // Verify all data received correctly
        if (sent_queue.size() != received_queue.size()) begin
            $display("ERROR: Queue size mismatch! Sent: %0d, Received: %0d", 
                     sent_queue.size(), received_queue.size());
            error_count++;
        end else begin
            $display("Queue sizes match: %0d transactions", sent_queue.size());
            for (int i = 0; i < sent_queue.size(); i++) begin
                if (sent_queue[i] != received_queue[i]) begin
                    $display("ERROR: Data mismatch at index %0d. Expected: 0x%h, Got: 0x%h",
                             i, sent_queue[i], received_queue[i]);
                    error_count++;
                end
            end
            if (error_count == 0)
                $display("All random data matched correctly!");
        end
        test_count++;
    endtask
    
    // Test 5: Reset behavior
    task test_reset();
        $display("\n--- Test 5: Reset During Operation ---");
        
        // Send data
        @(posedge clk);
        in_valid = 1;
        in_data = 32'h12345678;
        out_ready = 0;
        
        @(posedge clk);
        in_valid = 0;
        
        // Assert reset
        @(posedge clk);
        rst_n = 0;
        
        repeat(2) @(posedge clk);
        rst_n = 1;
        
        @(posedge clk);
        check("Valid cleared after reset", out_valid, 1'b0);
        check("Ready asserted after reset", in_ready, 1'b1);
        
    endtask
    
    // Helper task for checking values
    task check(string name, logic [DATA_WIDTH-1:0] actual, logic [DATA_WIDTH-1:0] expected);
        test_count++;
        if (actual !== expected) begin
            $display("FAIL: %s - Expected: 0x%h, Got: 0x%h", name, expected, actual);
            error_count++;
        end else begin
            $display("PASS: %s", name);
        end
    endtask
    
    // Timeout watchdog
    initial begin
        #100000;
        $display("ERROR: Testbench timeout!");
        $finish;
    end

endmodule
